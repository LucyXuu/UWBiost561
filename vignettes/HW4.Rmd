---
4title: "HW4"
output: html_document
date: "2025-06-09"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(UWBiost561)
library(testthat)
```

### Question 1B

Both functions uses the greedy algorithm, only #13 starts with all nodes in the clique, and remove the one node that causes the density to increase the most until alpha level is above required value, while #9 starts with each individual node, add the next node into the clique until the alpha level is lower than needed.

### Question 1C

One thing /#9 can improve is to move the density calculation part out of the function and create a helper function. Also, both /#9 and /#13 could name variables with meaningfun words that represents its use, for example changing S to current candidate, and m to max clique size. 

### Question 1D

I've slightly altered the test because the error messages have difference in wording yet hold same meaning

Test #13:

```{r, error=TRUE}
test_that("compute_maximal_partial_clique works", {
  set.seed(1)
  mat <- generate_partial_clique(n = 10,
                                 clique_fraction = 0.5,
                                 clique_edge_density = 0.9)$adj_mat
  res <- compute_maximal_partial_clique13(mat, 0.9)
  #1: Checking that the function outputs something that is the correct type
  expect_true(is.list(res))
  #2: Simple checks to make sure outputs are within the correct range
  expect_true(all(res$clique_idx %in% 1:nrow(mat)))
  expect_true(res$edge_density >= 0.9)
})
#3: Making sure the function runs on many different inputs
test_that("function runs on different input", {
  set.seed(1)
  mat1 <- generate_partial_clique(n = 10,
                                 clique_fraction = 0.5,
                                 clique_edge_density = 0.9)$adj_mat
  res1 <- compute_maximal_partial_clique13(mat1, 0.9)

  mat2 <- generate_partial_clique(n = 12,
                                  clique_fraction = 0.7,
                                  clique_edge_density = 0.8)$adj_mat
  res2 <- compute_maximal_partial_clique13(mat2, 0.8)

  mat3 <- generate_partial_clique(n = 11,
                                  clique_fraction = 0.5,
                                  clique_edge_density = 0.7)$adj_mat
  res3 <- compute_maximal_partial_clique13(mat3, 0.7)
  expect_false(identical(res1, res2))
  expect_false(identical(res1, res3))
  expect_false(identical(res2, res3))
})

#4: Testing to make sure it errors when expected
test_that("error on invalid matrix", {
  expect_error(
    compute_maximal_partial_clique13(matrix(c(1)), 0.9),
    "`adj_mat` must have between 5 and 50 rows/columns"
  )
})

#7: Testing the behavior when there is deliberately no unique answer
test_that("test on deliberately no unique", {
  adj_mat <- matrix(c(
    1, 1, 1, 0, 0, 0,
    1, 1, 1, 1, 0, 0,
    1, 1, 1, 0, 1, 0,
    0, 1, 0, 1, 1, 1,
    0, 0, 1, 1, 1, 1,
    0, 0, 0, 1, 1, 1
  ), nrow = 6, byrow = TRUE)
  res <- compute_maximal_partial_clique13(adj_mat, alpha = 0.8)
  expect_true(is.list(res))
  expect_true(length(res) > 0)
  expect_true(res$edge_density > 0.8)
})



```

Test #9:

```{r}
test_that("compute_maximal_partial_clique works", {
  set.seed(1)
  mat <- generate_partial_clique(n = 10,
                                 clique_fraction = 0.5,
                                 clique_edge_density = 0.9)$adj_mat
  res <- compute_maximal_partial_clique9(mat, 0.9)
  #1: Checking that the function outputs something that is the correct type
  expect_true(is.list(res))
  #2: Simple checks to make sure outputs are within the correct range
  expect_true(all(res$clique_idx %in% 1:nrow(mat)))
  expect_true(res$edge_density >= 0.9)
})
#3: Making sure the function runs on many different inputs
test_that("function runs on different input", {
  set.seed(1)
  mat1 <- generate_partial_clique(n = 10,
                                 clique_fraction = 0.5,
                                 clique_edge_density = 0.9)$adj_mat
  res1 <- compute_maximal_partial_clique9(mat1, 0.9)

  mat2 <- generate_partial_clique(n = 12,
                                  clique_fraction = 0.7,
                                  clique_edge_density = 0.8)$adj_mat
  res2 <- compute_maximal_partial_clique9(mat2, 0.8)

  mat3 <- generate_partial_clique(n = 11,
                                  clique_fraction = 0.5,
                                  clique_edge_density = 0.7)$adj_mat
  res3 <- compute_maximal_partial_clique9(mat3, 0.7)
  expect_false(identical(res1, res2))
  expect_false(identical(res1, res3))
  expect_false(identical(res2, res3))
})

#4: Testing to make sure it errors when expected
test_that("error on invalid matrix", {
  expect_error(
    compute_maximal_partial_clique9(matrix(c(1)), 0.9),
    "adj_mat must be between 5 and 50 rows/columns"
  )
})

#7: Testing the behavior when there is deliberately no unique answer
test_that("test on deliberately no unique", {
  adj_mat <- matrix(c(
    1, 1, 1, 0, 0, 0,
    1, 1, 1, 1, 0, 0,
    1, 1, 1, 0, 1, 0,
    0, 1, 0, 1, 1, 1,
    0, 0, 1, 1, 1, 1,
    0, 0, 0, 1, 1, 1
  ), nrow = 6, byrow = TRUE)
  res <- compute_maximal_partial_clique9(adj_mat, alpha = 0.8)
  expect_true(is.list(res))
  expect_true(length(res) > 0)
  expect_true(res$edge_density > 0.8)
})



```



```{r}
library(UWBiost561)
set.seed(10)
data <- UWBiost561::generate_partial_clique(n = 10, 
                                            clique_fraction = 0.5,
                                            clique_edge_density = 0.95)

set.seed(10)
result1 <- UWBiost561::compute_maximal_partial_clique_master(
  adj_mat = data$adj_mat, 
  alpha = 0.95, 
  number = 2, 
  time_limit = 30
)
result1

set.seed(10)
result2 <- UWBiost561::compute_maximal_partial_clique11(
  adj_mat = data$adj_mat, 
  alpha = 0.95
)
result2
```

### Question 2B

1. I will generate the random graphs using the generate_partial_clique() function. The graph has n nodes, a subset of nodes will be randomly selected ro form a partial clique that satisfy the alpha level, the size of clique determined by clique_fraction * n.

2. I will be varying the clique_edge_density in the simulation

3. I will be using the 15 methods

4. I hope to learn if these methods yeild similiar result, and if the result is accurate and stable over each trial.

5. I intend to run 3 trials per level.

6. The maximum time needed is 45 minutes, however it will take less time because most trial will not take the maximum 30 seconds.


### Question 2C

```{r}
imp_numbers <- 1:15
trials <- 2
clique_edge_density_vec <- c(0.3, 0.7)



results <- simulation_study(trials, clique_edge_density_vec)
```
















